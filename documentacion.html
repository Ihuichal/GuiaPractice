<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Práctica Profesional</title>
  <style>
  body {
    background-color:#26a69a;
  }
  </style>

  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link href="css/materialize.css" type="text/css" rel="stylesheet" media="screen,projection"/>
  <link href="css/style.css" type="text/css" rel="stylesheet" media="screen,projection"/>
</head>
<!-- *************************************************************************************************+***************-->
<body >
<!-- *************************************************************************************************+***************-->
    <div id="index-banner" class="parallax-container">
    <div class="section no-pad-bot">
      <div class="container">
        <br><br>
        <h1 class="header center teal-text text-lighten-2">DOCUMENTACIÓN</h1>
        <div class="row center">
          <div><img src="images/optilogo.png"></div>
        </div>
        <br><br>
      </div>
    </div>
    <div class="parallax"><img src="images/imadoc.jpg" alt="Unsplashed image img 1"></div>
  </div>
<!-- *************************************************************************************************+***************-->
    <div id="index-banner" class="documentation">
<!-- *************************************************************************************************+***************-->
    <div class="card ">
      <div class="card-content teal darken-1" > <!--COLOR DEL FONDO DE LAS CARD -->
        <span style = "color:white; font-size: 50px;" class="card-title"><b><TT><u>INICIACIÓN DEL PROYECTO</u></tt><b></span></br>
          <p style="font-size: 18px;">
            <CODE style="color:#fafafa;">
              Ante la propuesta de trabajo, la cual consiste en desarrollar aplicaciones móviles nativas,
               que son las que se desarrollan específicamente para cada sistema operativo, lenguaje Swift
                para iOS, Java para Android. Con el foco principal apuntando a la integración continua, lo
                que se traduce en compilar y ejecutar pruebas en todo el código que se va generando.</br>
              La primera actividad consistió en estudiar y posteriormente seleccionar las herramientas para
              trabajar. En este contexto, iniciamos con las instalación de los entornos de desarrollo Android
              Studio y Xcode, se crearon cuentas en GitHub y Jira Atlassian, así ya contábamos con herramientas
              de desarrollo, almacenaje y gestión del proyecto.</br>
              A pesar de que existen más ofertas con respecto a herramientas de repositorio y gestión de proyectos,
               se decidió trabajar con GitHub por la razón de que se tenía una idea formada de cómo se utiliza
               apropiadamente, por otro lado Jira Atlassian fue escogido por ser desconocido y además porque la
               empresa en sí, quería familiarizarse con esta herramienta. </br>
              Se partió con la ejecución de una serie de tutoriales para desarrollar aplicaciones móviles y a la vez
               hacer uso de los repositorios y el instrumento de gestión.</br>
              Para la realización de los tutoriales se utilizó la documentación existente en las páginas de Android y
               Apple respectivamente, con ello se nos permitió hacer distintos tipos de pruebas las cuales van desde
               hacer un “Hello World”, hasta hacer una conexión “http” o “https”.</br>
              Luego, se eligió una herramienta de integración continua para estudiarla y ponerla en marcha con una de
              las aplicaciones creadas como prueba. Jenkins fue el instrumento escogido, se logró instalarlo en un servidor
              local, enlazarlo con un proyecto alojado en GitHub, de modo que cada cierto tiempo realizaba una compilación
              del código y en caso de encontrar algún error, este quedaría registrado, para poder arreglarlo. </br>
              Para integrar Jenkins, es necesario instalar una serie de plugins como soporte dependiendo del tipo de
              aplicación que se esté desarrollando, ya que existen plugins diferentes para aplicaciones Android y IOs.
              Esto permitirá que reconozca el lenguaje y efectué la compilación correctamente.</br>
            </code>
          </p>
        </br>
        <div class="card-action">
          <a target="_blank" href="https://aws.amazon.com/es/devops/continuous-integration/" style="font-size: 15px; color:#0d47a1;" ><u>Integración continua</u></a>
          <a target="_blank" href="http://qode.pro/blog/que-es-una-app-nativa/"style="font-size: 15px; color:#0d47a1;"><u>Aplicaciones móviles nativas</u></a>
        </div>
        <div class="card-action">
          <a target="_blank" href="https://developer.android.com/studio/index.html?hl=es-419" style="font-size: 15px; color:#0d47a1;"><u>Android Studio</u></a>
          <a target="_blank" href="https://developer.apple.com/xcode/" style="font-size: 15px; color:#0d47a1;"><u>Xcode</u></a>
          <a target="_blank" href="https://github.com/" style="font-size: 15px; color:#0d47a1;"><u>GitHub</u></a>
          <a target="_blank" href="https://es.atlassian.com/software/jira" style="font-size: 15px; color:#0d47a1;"><u>Jira Atlassian</u></a>
          <a target="_blank" href="https://jenkins.io/" style="font-size: 15px; color:#0d47a1;"><u>Jenkins</u></a>
        </div>
        <div class="card-action">
          <a target="_blank" href="https://developer.android.com/develop/index.html" style="font-size: 15px; color:#0d47a1;"><u>Documentación Android</u></a>
          <a target="_blank" href="https://developer.apple.com/documentation/" style="font-size: 15px; color:#0d47a1;"><u>Documentación Apple</u></a>
        </div>
      </div>
    </div>
<!-- *************************************************************************************************+***************-->
    </br>   <!--Semana 2-->
<!-- *************************************************************************************************+***************-->
    <div class="card ">
  <div class="card-content teal darken-1" > <!--COLOR DEL FONDO DE LAS CARD -->
    <span style = "color:white; font-size: 50px;" class="card-title"><b><TT><u>ANÁLISIS DEL SISTEMA</u></tt><b></span></br>
      <p>
        <CODE style="color:#fafafa; font-size: 18px;">
          En este periodo ya había una idea más clara sobre que se tenía que desarrollar,
          pero se decidió por seguir haciendo distintas pruebas de modo de lograr integrar
          Jenkins tanto a aplicaciones Android y IOs.</br>
          Se desarrolló una aplicación en Android la cual, al presionar un botón se obtiene
           la dirección Mac del dispositivo. Para ello se utilizó la documentación y videotutoriales,
           que simplificaron los tiempos de desarrollo.</br>
          </br><center> <img class="centrado" src="images/s21.png" ></center></br>
          Las aplicaciones, fueron almacenadas en el repositorio Github y para esto se utilizaron
           una serie de comandos en la terminal para registrar los avances.</br>
          Entre los comandos usados tenemos:</br>
          &#9702; git init : para iniciar repositorio en un directorio.</br>
          &#9702; git add. : para agregar todo el contenido modificado o nuevo.</br>
          &#9702; git commit -m “mensaje” : se utiliza para consignar un conjunto de cambios.</br>
          &#9702; git push : usado para subir los archivos.</br>
          &#9702; git branch : se utilizó para crear funcionalidades sin dañar la rama principal.</br>
          &#9702; git checkout : se usa para moverse entre ramas o commits.</br>
          &#9702; git merge : utilizado para fusionar las nuevas funcionalidades
          creadas en las ramas con la rama master.</br>
          Lo presentado hasta en su mayoría está dentro de la capa de presentación (Front end),
          esto dado que es más simple trabajar. </br></br>
          La configuración con Jenkins al inicio no fue algo trivial, de hecho tomó varias horas
          para lograrlo. Pero siguiendo estos pasos, no debería haber problema alguno :</br>
          1.- Instalar Jenkins.</br>
          2.- Entrar a la opción ‘Administrar Jenkins’ y luego a ‘Configuración’.</br>
          3.- Agregar una variable de entorno, referenciando a ‘Android SKD’.</br>
          </br><center> <img class="centrado" src="images/s22.png" ></center></br>
          4.- Volver a ‘Administrar Jenkins’’ y entrar a ‘Global Tool Configuration’.</br>
          5.- Realizar las siguientes instalaciones:</br>
          </br><center> <img class="centrado" src="images/s23.png" ></center></br>
          </br><center> <img class="centrado" src="images/s24.png" ></center></br>
          </br><center> <img class="centrado" src="images/s25.png" ></center></br>
          6.- Una vez más, regresar a ‘Administrar Jenkins’ y dirigirse a ‘Administrar Plugins’.</br>
          7.- Ir a ‘Todos los plugins’ e instalar ‘Jenkins Gradle plugins’.</br>
          Una vez configurado, se debe crear una nueva tarea con un nombre a elección y se debe hacer
           las siguientes configuraciones, enlazar Jenkins con nuestro repositorio y emplear la ejecución
            de nuestro proyecto en Jenkins.</br>
          </br><center> <img class="centrado" src="images/s26.png" ></center></br>
          </br><center> <img class="centrado" src="images/s27.png" ></center></br>
          En esta última, basta con abrir ‘Añadir un nuevo paso’ y seleccionar ‘Invoke Gradle script’ y
          luego asociarla con la variable de entorno instalada anteriormente.</br>
          Posteriormente se empezó a trabajar la parte referente a la capa de acceso a datos (Back end),
          para ello se decidió trabajar con Node.js y MongoDB el cual es una base de datos NoSQL.</br>
          Node.js hoy en día juega un papel importante en la pila de tecnologías de muchas empresas de alto
          perfil, es por ello que se decidió contar con esta herramienta. Respecto a MongoDB esta es considera
          la base de datos NoSQL líder y debido a que existe mucha documentación sobre su uso, se decidió
          por optar por ella.</br>
          Se partió estudiando cómo definir una API, como configurar mongodb para tener una base de datos
          local y como hace conexión del dispositivo móvil con un servidor, utilizando el protocolo Http.</br></br>
        </code>
      </p>
      <div class="card-action">
        <a target="_blank" href="https://nodejs.org/es/" style="font-size: 15px; color:#0d47a1;" ><u>Node.js</u></a>
        <a target="_blank" href="https://www.mongodb.com/es" style="font-size: 15px; color:#0d47a1;" ><u>MongoDB</u></a>
        <a target="_blank" href="http://rogerdudler.github.io/git-guide/index.es.html" style="font-size: 15px; color:#0d47a1;" ><u>Guía GitHub</u></a>
      </div>
    </div>
  </div>
<!-- *************************************************************************************************+***************-->
    </br>  <!--Semana 3-->
<!-- *************************************************************************************************+***************-->
    <div class="card ">
  <div class="card-content teal darken-1" > <!--COLOR DEL FONDO DE LAS CARD -->
    <span style = "color:white; font-size: 50px;" class="card-title"><b><TT><u>DISEÑO Y CONSTRUCCIÓN</u></tt><b></span></br>
      <p>
        <CODE style="color:#fafafa; font-size: 18px;">
          <center><img style="float:right;" class="centrado" src="images/s31.png" ></center>
          Se inició el desarrollo de la aplicación móvil para Android, haciendo uso de git para
          desarrollar el proyecto en módulos, entre las tareas más destacadas podemos diferenciar las siguientes:</br>
          &#9702; Módulo para obtener la Geoposición.</br>
          &#9702; Método para obtener id “Mac”.</br>
          &#9702; Módulo de comunicación Https.</br>
          &#9702; Vista de la aplicación.</br>
          &rarr; <big>Estructura de la aplicación:</big> </br>
          El framework de Android separa el proyecto en directorios </br>
          &rarr; <big>APP: se separa en tres sub directorios:</big> </br>
          &#9702; Manifests:Contiene el archivo que con los permisos y configuraciones
          iniciales de la Aplicación.</br>
          &#9702; Java:Contiene los archivos con las clases en java donde se programan
          las lógicas de la aplicación.</br>
          &#9702; Res: Contiene los archivos de las vistas, para el diseño de
          vistas de la app, los archivos de aca son de lenguaje de etiquetas XML donde
          se pueden definir recursos de widget como botones, labels, formularios, etc.</br>

          &#8211; Método para obtener  la posición</br>
          Para este método se usaron las librerías que proporciona Android para detectar
          la posición del celular mediante GPS. ‘Location Manager’ es una clase que nos permite
          capturar esta información, además de otras clases para almacenar las instancias como
          Location() y location Listener.</br>
          &#8211; Método para obtener la mac del dispositivo :</br>
          MacDevice.java es una clase que se ejecuta en el dispositivo y retorna un string con la mac. </br>
          &#8211; Comunicación HTTPS</br>
          Para ejecutar peticiones HTTPS tuvimos que crear clases que extienden de la Clase AsincronycTasck(),
           para mantener la comunicación en otro hilo de ejecución, además de importar la librería HttpsUrlConnection()
            que sostiene los métodos para formar las peticiones Response y brinda de un mecanismo para
            tratar los Response. </br>
          &#8211; Cambio de repositorio </br>
          Para seguir con el  alineamiento estratégico de la empresa  decidimos cambiar de servidor de repositorio
           de GitHub a Bitbucket puesto que este último es una Herramienta de Atlassians y pensamos que nos podría
           dar sinergia con Jira.</br>
          &#8211; Vista de la aplicación </br>

          En el directorio res  se encuentran los Layouts que describen tanto en forma gráfica como lenguaje XML
           los componentes de las vistas </br>
          </br><center> <img class="centrado" src="images/s32.png"></center></br>
          &#8211; Servidor local </br>
          Para hacer pruebas de comunicación  levantamos un servicio de Api local con Nodejs utilizando el
          Framework de Express conectado con una base de datos Mongodb. </br></br>
          Como la aplicación inicial consistía solamente de un simple botón que interactuaba con una base
          de datos, se decidió por mejorarla añadiendo más funcionalidad. Tanto para dispositivos IOs como
           para Android se creó una nueva vista en la cual es posible ver el historial de registros asociados
           al dispositivo móvil.</br>
          <table>
            <tbody>
              <tr>
                <td>
                  </br><center> <img class="centrado" src="images/s33.png" ></center></br>
                </td>
                <td>
                  </br><center> <img class="centrado" src="images/s34.png" ></center></br>
                </td>
              </tr>
            </tbody>
        </table>

      </code>
      </p>
      <div class="card-action">
        <a target="_blank" href="https://aws.amazon.com/es/training/?nc2=h_l2_tr" style="font-size: 15px; color:#0d47a1;" ><u>Capacitación</u></a>
        <a target="_blank" href="https://docs.aws.amazon.com/es_es/apigateway/latest/developerguide/welcome.html" style="font-size: 15px; color:#0d47a1;" ><u>API Gateway</u></a>
      </div>
    </div>
  </div>
<!-- ************************************************************************************************+***************-->
    </br>  <!--Semana 4-->
<!-- *************************************************************************************************+***************-->
    <div class="card ">
  <div class="card-content teal darken-1" > <!--COLOR DEL FONDO DE LAS CARD -->
    <span style = "color:white; font-size: 50px;" class="card-title"><b><TT><u>DESPLIEGUE MANUAL</u></tt><b></span></br>
      <p>
        <CODE style="color:#fafafa; font-size: 18px;">
          &rarr; <big>Plataforma AWS</big></br>
          Amazon nos proporciona una gran cantidad de servicios en la nube.
          En este marco de trabajo, utilizaremos solo 2 (Lambda, y Api GateWay).</br>
            &rarr; <big>Funciones en Lambda:</big> </br>
          Una función es un código con entradas que será ejecutado por Amazon y que pueden efectuar una acción que puede interactuar con otros recursos de amazon, estas funciones pueden ser escritas en varios lenguajes por ejemplo Java, C, Python, NodeJs, nosotros elegimos usar NodeJs para conservar el modelo actual. </br>
          Para crear una función de Lambda, se hace de la siguiente forma: </br>
          Dentro de AWS selecciona el servicio de Lambda, y selecciona la opción de crear una nueva función. </br>
          </br><center> <img class="centrado" src="images/s41.png" ></center></br>
          Ahora hay que completar los siguientes campos nombre de la funcion, descripcion, runtime y role. </br>
          </br><center> <img class="centrado" src="images/s42.png" ></center></br>
          Nombre: Corresponde al nombre para identificar tu función.</br>
          Descripción: Permite poner una descripción de la función.</br>
          Runtime: Corresponde al intérprete en el cual correrá el código, puede ser Java, Python, Script.</br>
          Role: Los roles en Amazon definen los permisos que nuestra función tendrá con otros recursos y servicios de Amazon. ver IAM de Amazon para gestionar roles.</br>
          Completado los recursos, ahora ya tienes una función hecha en Lambda, nosotros escogimos usar NodeJs para codificar nuestras funciones, Los recursos a los cuales nuestras funciones podrán acceder las dará el role que se le asigne a la función. mientras que los triggers se pueden configurar desde la función. para efectos de nuestra primera prueba, hicimos una función que retorna un atributo de la llegada.</br>
          </br> <center><img class="centrado" src="images/s43.png" ></center></br>
          <center><img style="float:right;" class="centrado" src="images/s44.png" ></center></br>
          Las entradas de una función de Lambda son estructuras del tipo Json por como el siguiente:</br>
          </br></br>
          </br></br>
          Estas  pueden provenir del API Gateway si lo configuras como Trigger
          de lanzamiento para la función, aunque igual puede ser ejecutado por
          varios otros servicios de amazon.</br>
          En nuestro caso lo configuramos pensando en recibir una
          llamada proveniente de API Gateway. </br>
          </br> <center><img class="centrado" src="images/s45.png" ></center></br>
          API Gateway es un servicio que facilita la comunicación de los demás servicios
          de amazon proporciona sistemas de Rooteos y sistemas de autentificación que le
          pondremos el foco en la siguiente sprint. pero lo dejamos configurado para que
          reciba las peticiones HTTPs  provenientes de nuestra aplicacion y las comunique con
          el microservicios de lamda.</br>
          </br> <center><img class="centrado" src="images/s46.png" ></center></br>

          </code>
        </p>
      <div class="card-action">
        <a target="_blank"  href="https://aws.amazon.com/es/free/?sc_channel=PS&sc_campaign=acquisition_CL&sc_publisher=google&sc_medium=english_cloud_computing_hv_b&sc_content=aws_core_e&sc_detail=aws&sc_category=cloud_computing&sc_segment=188900648287&sc_matchtype=e&sc_country=CL&s_kwcid=AL!4422!3!188900648287!e!!g!!aws&ef_id=WldLDQAAADmz96cK:20180202155127:s" style="font-size: 15px; color:#0d47a1;" ><u>Amazon Web Services</u></a>
      </div>
    </div>
  </div>
<!-- *************************************************************************************************+***************-->
    <br>  <!--semana 5-->
<!-- *************************************************************************************************+***************-->
    <div class="card ">
  <div class="card-content teal darken-1" > <!--COLOR DEL FONDO DE LAS CARD -->
    <span style = "color:white; font-size: 50px;" class="card-title"><b><TT><u>INTEGRACIÓN CONTINUA</u></tt><b></span></br>
      <p>
        <CODE style="color:#fafafa; font-size: 18px;">
          <center><img style="float:right;" class="centrado" src="images/s51.png" ></center>
          Luego de desarrollar la aplicación móvil para dispositivos Android. Se comenzó el desarrollo de la aplicación para dispositivos IOs, para esto se utilizó el lenguaje de programación Swift y Xcode como entorno de desarrollo. Se ocupó la documentación oficial y una serie de tutoriales para construir la aplicación.</br>
          La aplicación construida consiste únicamente en enviar datos a una base de datos NOSQL, esto al momento de presionar un botón, y una serie de validaciones para ello.</br>
          Al presionar el botón “REGISTRAR AHORA”, se envia una dirección del dispositivo como identificador, y los datos de la ubicación, esto es coordenadas latitud y longitud. Al llegar al servidor, primero comprueba si la dirección del dispositivo corresponde a un usuario registrado, en caso contrario devuelve error como respuesta. Luego con los valores latitud y longitud utilizando la API de google, determina la dirección desde la cual se envían los datos. Finalmente los datos se registran en la base de datos, adjuntando el nombre asociado al dispositivo, dirección, hora actual, id del dispositivo, latitud y longitud.</br>
          Una vez que la aplicación ya realizaba las funciones descritas, se puso en marcha la adaptación de Jenkins para las aplicaciones desarrolladas para Android y IOs.</br>
          El objetivo de esto era establecer una herramienta que estuviera atenta  al sistema de control de versiones (Bitbucket) para revisar los cambios. Cada vez que detectara un cambio, la herramienta de manera automática compilara, con la idea de detecta si algo va mal, para notificar o simplemente evidenciar que todo sigue funcionando correctamente. Con esto se estaría empleando integración continua de una forma sencilla.</br>
          La instalación de Jenkins se realizó en un computador de los miembros del equipo, de modo que se utilizó un servidor local para tener andando el software. Los pasos para la instalación de Jenkins, se pueden obtener directamente de la página oficial.
          Para emplear el uso de Jenkins, lo primero es instalar el plugin “Bitbucket Plugin”, después se debe proporcionar el acceso a los repositorios Bitbucket.</br>
          Ya que nuestros repositorios son privados, los pasos para tener acceso a ellos es el siguiente:</br>
          &#9702; Abrir una terminal.</br>
          &#9702; Ejecutar $sudo su jenkins.</br>
          &#9702; Ejecutar $shh-keygen.</br>
          &#8211; Presionar “enter" tres veces.</br>
          Con estos pasos ya se puede obtener una ssh-keygen. El paso siguiente es agregar
          esta llave a bitbucket y asignarle un nombre.</br>
          </br><center> <img class="centrado" src="images/s52.png" ></center></br>
          </br><center> <img class="centrado" src="images/s53.png" ></center></br>
          El paso siguiente, es ir a Jenkins y agregar una credencial asociada a la SSH key.</br>
          <table>
            <tbody>
              <tr>
                <td>
                  </br><center> <img class="centrado" src="images/s54.png" ></center></br>
                </td>
                <td>
                  </br><center> <img class="centrado" src="images/s55.png" ></center></br>
                </td>
                <td>
                  </br><center> <img class="centrado" src="images/s56.png" ></center></br>
              </td>
            </tr>
          </tbody>
        </table>
        Finalmente, para asociar un repositorio a una tarea creada en Jenkins, hay que dirigirse a configuración de la tarea y hacer lo siguiente:</br>
        </br><center> <img class="centrado" src="images/s57.png" ></center></br>
        Se pega el enlace SSH que proporciona Bitbucket, y se asocia a la credencial creada.</br></br>
        Realizar configuración de Jenkins, para ejecutar pruebas en el código fuente, no es algo trivial, de hecho para cada tipo de desarrollo existen características diferentes.</br>
        Para adaptarlo al proyecto IOs, se encuentra el plugin “Xcode Integration”, el cual permite compilar el código fuente.</br>
        A continuación se muestra la adecuación de realizada en el software:</br>
        </br><center> <img class="centrado" src="images/s58.png" ></center></br>
        </br><center> <img class="centrado" src="images/s59.png" ></center></br>
        </br><center> <img class="centrado" src="images/s510.png" ></center></br>
        Lo importante aquí, es tener claridad respecto al nombre del esquema asociado al proyecto y además poseer un ID de desarrollador de Apple, para que sea posible realizar la compilación directa desde Jenkins.</br>
        La manera que tiene Jenkins de evidenciar el estado actual de un proyecto, es por medio de simbolo de colores. El azul significa que todo va bien y rojo que se produjo algún error, además la herramientas proporciona un historial de los resultados obtenidos.</br>
        <table>
            <tbody>
              <tr>
                <td>
                  </br><center> <img class="centrado" src="images/s514.png" ></center></br>
                </td>
                <td>
                  </br><center> <img class="centrado" src="images/s515.png" ></center></br>
                </td>
            </tr>
          </tbody>
        </table>
      </code>
    </p>
    <div class="card-action">
      <a target="_blank"  href="http://mmorejon.github.io/blog/integracion-continua-jenkins-ios9-xcode/" style="font-size: 15px; color:#0d47a1;"><u>Tutorial configuración Jenkins para IOs</u></a>
      <a target="_blank"  href="https://www.cloudbees.com/blog/building-android-gradle-apps-jenkins" style="font-size: 15px; color:#0d47a1;"><u>Tutorial configuración Jenkins para Android</u></a>
    </div>
  </div>
</div>
<!-- *************************************************************************************************+***************-->
    <br>  <!--semana 6-->
<!-- *************************************************************************************************+***************-->
    <div class="card ">
  <div class="card-content teal darken-1" > <!--COLOR DEL FONDO DE LAS CARD -->
    <span style = "color:white; font-size: 50px;" class="card-title"><b><TT><u>DESPLIEGUE CONTINUO</u></tt><b></span></br>
      <p>
        <CODE style="color:#fafafa; font-size: 18px;">
            &#8211; Lambda AWS localmente.</br>
            Trabajar Localmente con las funciones de lambda, equivale a una ventaja para avanzar colaborativamente.</br>
            Esto se logró, primero creando una carpeta con la estructura apropiada al Back-End.
            Luego se utilizó el gestor de paquetes "npm", y se instalaron los siguientes paquetes,
            uno para tener los accesos a los servicios de Amazon y otro para utilizar Lambda de forma local:</br>
            &#9702; npm install aws-sdk
            &#9702; npm install -g lambda-local
            luego de esto, en el código se deben agregar las Key de acceso de usuario a los servicios AWS.
            Una vez realizado los pasos mencionados, basta con ejecutar en terminal una instrucción de prueba:
            &#9702;lambda-local -l server.js -e event.js
            Donde event.js es un elemento para hacer un test, tiene la estructura siguiente:</br>
            module.exports =</br>
            {</br>
              "IdDevice":"0-a-f5-4f-90-74",</br>
              "latitud":"-33.417641",</br>
              "longitud":"-70.610304"</br>
            };</br>
            Esto simula el botón test que proporciona AWS</br>
            <table>
              <tbody>
                <tr>
                  <td>
                    </br><center> <img class="centrado" src="images/s61.png" ></center></br>
                  </td>
                  <td>
                    </br><center> <img class="centrado" src="images/s62.png" ></center></br>
                  </td>
                  <td>
                    </br><center> <img class="centrado" src="images/s63.png" ></center></br>
                  </td>
                </tr>
              </tbody>
            </table>
            &#8211; Deployment Funciones en lambda.</br>
            Para automatizar el deployment de las funciones de lambda en la nube desde el
            repositorio usamos 2 alternativas, plugins AWS-lambda  y  pipeline de bitbucket.</br></br>
            &#9702; Plugin AWS-lambda para jenkins.</br>
            Jenkins es nuestro servidor de integración y despliegue continua por defecto.
            cuenta con varios plugins que nos ayuda a automatizar varios procesos de  desarrollo
            como el de las pruebas automatizadas, para el caso de Lambda utilizamos un plugins
            “AWS Lambda Plugin”, que nos ayuda a automatizar el Despliegue de la aplicación.</br>
            Para utilizar este plugins la mecánica es crear una “tarea”, configurarla para bajar
            temporalmente la función desde nuestro repositorio de Bitbucket, Darle las credenciales de
            nuestra cuenta de amazon al servidor Jenkins mediante el plugins, y llenar las configuraciones
            de nuestra función de lambda. </br>
            </br><center> <img class="centrado" src="images/s64.png" ></center></br>
            los campos requeridos para el Deployment </br>
            &#8226; AWS ACCESS KEY ID : ID que proporciona AWS por medio de las cuentas de usuario.</br>
            &#8226; AWS Secret Key : Clave secreta del Id Access AWS.</br>
            &#8226; AWS Region : Region del servidor Aws donde se encuentra función de lambda.</br>
            &#8226; Funtion name : Nombre de la función a actualizar, si no existe se creará otra con ese nombre. </br>
            &#8226; Role : a cada función se le asigna un role que cuenta con los permisos para interactuar con los servicios
            de amazon inclusive los permisos para editar la app </br>
            &#8226; Artifactact Location : Refiere a la locación donde se encuentra
            ubicado el proyecto que se quiere subir a producción. hay varias opciones.
            (enviar un directorio, un zip, o  extraerla de s3 AWS(servicio de almacenamiento de Amazon)
            en nuestro caso  le dimos la ruta “/Users/Shared/Jenkins/Home/workspace/lambda” que alude a
            la carpeta donde se baja temporalmente  nuestro repositorio  en cada tarea.</br>
            &#8226; Handler name : Nombre del controlador de la función en lambda por defecto es Index.handler,
            depende del nombre del archivo principal que contiene la el método handler  de la función,
            en nuestro caso es Index.handler porque el archivo principal de llama server.js</br>
            &#8226; Memory Size:  Se le indica la cantidad de memoria que vamos a requerir para
            ejecutar este microservicio por defecto son 128 MB. </br>
            &#8226; Time out: Tiempo de corte para la  ejecución del microservicio.</br>
            &#8226; Runtime : lenguaje o compilador que ejecutará la función </br>
            &#8226; Update mode : Se llena con “full por defecto”</br></br>
            &#9702; PipeLine de Bitbucket </br>
            El servidor de repositorio Bitbucket  nos proporciona de un servicio
            de ejecución para nuestros códigos en la nube. este se puede aprovechar
            para hacer pruebas de integración y además para ejecutar script que nos permitan
            realizar Deployment continuo.</br>
            Para nuestro proyecto de microservicios en Lambda AWS utilizamos un
            script que automatiza el despliegue de las funciones desde el repositorio.</br>
            Los pipeline corren Script del tipo yml, incluimos en la raiz del proyecto
            el archivo bitbucket-pipelines.yml  con las instrucciones para hacer  en cada ejecución.</br>
            </br><center> <img class="centrado" src="images/s65.png" ></center></br>
            Este script requiere en cada instancia instalar zip para comprimir el repositorio.
            Instalar “boto3”, que es una librería requerida para comunicarse con amazon, y ejecuta
            un programa escrito en python llamado lambda_deploy.py que contiene la logica para enviar
            el zip a Amazon Lambda. </br>
            Las credenciales de Amazon para la enviar y editar las funciones de lambda en la
            nube se deben guardar en las variables de entorno de PipeLine de Bitbucket</br>
            </br><center> <img class="centrado" src="images/s66.png" ></center></br>
            Este método de Deployment es bastante cómodo porque es automatizado,
            con la actualización del repositorio de producción. cada ejecución se
            demora cerca de 40 segundos, tiempo que hay que considerar dado que pipeline
            de bitbucket tiene una capa gratuita de 50 minutos mensuales ampliables. Lo que
            podría ser suficiente para subir 80 versiones al mes. </br></br>
            &#8211; Diagramas de arquitectura de despliegue continuo para funciones de lambda usando Jenkins </br>
            </br><center> <img class="centrado" src="images/s67.png" ></center></br>
            </br><center> <img class="centrado" src="images/s68.png" ></center></br>
          </code>
        </p>
        <div class="card-action">
          <a  target="_blank" href="https://www.npmjs.com/package/lambda-local" style="font-size: 15px; color:#0d47a1;"><u>Lambda local</u></a>
          <a target="_blank" href="https://plugins.jenkins.io/aws-lambda" style="font-size: 15px; color:#0d47a1;"><u>Plugin Lambda AWS para Jenkins</u></a>
          <a target="_blank" href="https://bitbucket.org/awslabs/aws-lambda-bitbucket-pipelines-python" style="font-size: 15px; color:#0d47a1;"><u>Despliegue con Bitbucket</u></a>
          <a target="_blank" href="https://confluence.atlassian.com/bitbucket/limitations-of-bitbucket-pipelines-827106051.html" style="font-size: 15px; color:#0d47a1;"><u>Restricciones del despliegue con Bitbucket</u></a>
        </div>
      </div>
    </div>
<!-- *************************************************************************************************+***************-->
    <br>  <!--semana 7-->
<!-- *************************************************************************************************+***************-->
    <div class="card ">
      <div class="card-content teal darken-1" > <!--COLOR DEL FONDO DE LAS CARD -->
        <span style = "color:white; font-size: 50px;" class="card-title"><b><TT><u>PRUEBAS</u></tt><b></span></br>
          <p>
            <CODE style="font-size: 18px; color:#fafafa;">
                Las pruebas son básicamente un conjunto de actividades dentro del desarrollo, permiten conocer y mitigar los riesgos relacionados con el mal desempeño de las aplicaciones en los entornos de producción y realizar las correcciones necesarias antes de salir al mercado.</br>
                Se inició la etapa de investigación con el propósito principal  de implementar pruebas sobre los proyectos que ya realizamos (Android, IOS, Lambda). de tal manera de aumentar la calidad de lo que ya habíamos implementado asegurando su buen funcionamiento y facilitar la detección de fallos durante los procesos de integración continua de los proyectos.</br>
                En la actualidad existen muchas herramientas que permiten realizar pruebas, de hecho algunas son específicas para cada entorno. Sin embargo casi la totalidad de ellas son de pago. Por esto se decidió por emplear por realizar prueba unitarias y aunque su alcance es reducido y está perfectamente acotado, es suficiente para el tamaño o complejidad de la aplicación que se desarrolló.</br>
                &rarr; <big>Tipos de Pruebas</big></br>
                Es posible realizar distintos tipos de pruebas para las aplicaciones desarrolladas, las cuales se pueden considerar en una estrategia de prueba. En este contexto encontramos, pruebas de interrupción, interfaz de usuario, usabilidad, accesibilidad, movilidad, conectividad, seguridad, desempeño y compatibilidad.</br>
                Las pruebas que se pondrán en marcha, serán la de interfaz, usabilidad y movilidad.</br>
                &#9702; Prueba de interfaz: Se analizarán la organización en distintas pantallas, alineamiento y color principalmente.</br>
                &#9702; Prueba de usabilidad: Buscaremos efectuar una presentación clara de información, facilidad para hacer tareas, lograr eficiencia y exactitud.</br>
                &#9702; Prueba de movilidad: Un elemento clave es la geolocalización, por ello se realizarán pruebas al GPS del dispositivo.</br>
                &rarr; Testing sobre aplicaciones móviles:</br>
                Para el diseño de prueba dentro del marco de aplicaciones móviles, hay que tomar en cuenta el ambiente donde se estarán ejecutando estas pruebas. en nuestro caso habrá pruebas que serán ejecutadas dentro de los entornos de desarrollos y en ambientes de prueba  emuladas en el servidor de integración continua (Jenkins).</br>
                &rarr; Testing en Android :</br>
                El framework de desarrollo de Android Studio nos facilita la implementación de los test, la estructura del proyecto nos define donde debemos escribir nuestras pruebas:</br>
                </br><center> <img class="centrado" src="images/s71.png" ></center></br>
                Podemos identificar 2 tipos básicos de pruebas:</br>
                - Pruebas Junit en JVM local</br>
 	              - Pruebas instrumentales que se pueden ejecutar en un dispositivo emulado. </br>
                Las pruebas con el framework de Junit están enfocadas a probar funciones, métodos o clases hechos en Java y que no tengan dependencias con el core de Android , es por eso que se ejecutan sobre la máquina virtual de java. Estas pruebas deben ser escritas  en el directorio test del proyecto, dentro de la clase ExampleUnitTest o en otro archivo dentro de la misma carpeta.</br>
                </br><center> <img class="centrado" src="images/s72.png" ></center></br>
                - Adition_isCorrect() es un ejemplo básico de una prueba que siempre “pasa” puesto que verifica que 2+2 sea igual que 4 .</br>
                - Macnonull()  es una prueba que verifica que la saluda del método getMacAddress() no esté retornando nulo.</br>
                Las pruebas Instrumentales simulan más el comportamiento de las clases que dependen del core de Android. nos permiten acceder a información como el context y desde aquí se implementan también las pruebas de interacción con el usuario, estas pruebas deben ser escritas  en el directorio AndroidTest del proyecto, dentro de la clase ExampleInstruemntedTest o en otro archivo dentro de la misma carpeta.</br>
                </br><center> <img class="centrado" src="images/s73.png" ></center></br>
                UseAPPContext() es el test de ejemplo que viene en el proyecto que siempre pasa, y comprueba si el nombre del package es el que se el que  se tenía a un comienzo. </br>
                </br><center> <img class="centrado" src="images/s74.png" ></center></br>
                Siguiendo el ejemplo, hizo un test como un método “Context()” que verificará con la librería Junit 4 que el permiso de LOCATION_SERVICE fuera distinto de null. </br>
                Por último se hicieron pruebas de interfaz con la herramienta Espresso que viene integrada a Android Studio, esta consiste en ‘recordar’ un conjunto de interacciones con la aplicación se puede comprobar el estado de ciertas componentes de la aplicación como los Textview, botones ,textEdit y otros componente. Para ejecutar estas pruebas hay que dar a la opción Record Espresso Test en el menú run.</br>
                </br><center> <img class="centrado" src="images/s75.png" ></center></br>
                </br><center> <img class="centrado" src="images/s76.png" ></center></br>
                Seguido se iniciará el simulador android, Se irán registrando todas las acciones que ocurran con la aplicación. </br>
                </br><center> <img class="centrado" src="images/s78.png" ></center></br>
                Hay que considerar  que se deben agregar algunas dependencias en el Gradle</br>
                &rarr; <big>Testing en Backend</big> </br>
                La realización de pruebas en el Backend, fue posible llevarlas a cabo de distintas formas, de hecho implementamos 3 maneras distintas de ejecutar las pruebas y todas se implementaron con Jenkins.</br>
                -Postman, el cual es usado para simplificar el desarrollo de API, admite todas las etapas del ciclo de vida de una API.</br>
                La configuración para poder hacer pruebas utilizando Postman es la siguiente:</br>
                Se creó una colección, dentro de la cual se pueden añadir distintas “tab” capaces de interactuar con la API, mediante los métodos POST Y GET. Luego se añadieron una par de “tab”, en la cual se definió el método y su cuerpo para ser enviadas.</br>
                </br><center> <img class="centrado" src="images/s79.png" ></center></br>
                Para ejecutarla por medio de Jenkins, basta con crear una nueva tarea y posteriormente configurarla de la siguiente manera, establecer un entorno de ejecución y ejecutar una línea de comando, que sea capaz de iniciar la colección creada en Postman(Esta colección debe ser exportada y dejada en una carpeta fácilmente accesible).</br>
                </br><center> <img class="centrado" src="images/s710.png" ></center></br>
                Para poder ejecutar una línea de comando, es necesario ir hasta la opción “añadir un nuevo paso” y elegir “Ejecutar línea de comando (shell)”.</br>
                -Curl, corresponde es una librería de funciones que sirve para conectarse con servidores, realiza su trabajo con formato URL. De hecho basta con poner una línea de comando para realizar una prueba. En la misma línea de comando se especifican las características de la consulta que se realizará.</br>
                </br><center> <img class="centrado" src="images/s77.png" ></center></br>
                Para utilizarlo en Jenkins, basto con configurarlo para que ejecute una línea de comando.</br>
                </br><center> <img class="centrado" src="images/s711.png" ></center></br>
                -Plugins Jenkins, fue necesario instalar AWS Lambda Plugins para poder interactuar directamente con las funciones lambda y poder así realizar pruebas. Creando una nueva tarea, simplemente quedaría configurar el plugins. Entonces, vamos a la opción “añadir un nuevo paso” y seleccionamos “AWS Lambda invocation”, y se llena las casillas con la información correspondiente, esto es claves de acceso, región, nombre de la función lambda y el cuerpo del JSON.</br>
                </br><center> <img class="centrado" src="images/s712.png" ></center></br>
                &rarr; <big>Testing en IOS</big> </br>
                Así como para dispositivos Android, se realizó testing unitario para verificar de forma individual la funcionalidad de la aplicación.</br>
                El test unitario permite verificar de forma individual una funcionalidad de nuestra aplicación, es representado por segmentos de código. </br>
                Se utilizó el soporte de pruebas UI, que funciona como caso de prueba unitaria y tiene una configuración que permite grabar pruebas de UI. Una vez posicionado dentro de la clase, vate con ir situarse dentro de un método y activar el botón Recorder (botón de color rojo), con el cual podemos proceder a grabar nuestras pruebas de regresión.</br>
                - Presionamos en el botón Record UI Test y procedemos a grabar la prueba.</br>
                - En ese momento arranca la aplicación en una máquina virtual.</br>
                - Mientras se interactúa con la aplicación, se van agregando líneas de código que automatizará la prueba.</br>
                - Para finalizar, presionamos el botón Stop Recording UI Test.</br>
                </br><center> <img class="centrado" src="images/s720.png" ></center></br>
                Para ejecutar la prueba, vamos al menú y seleccionamos ‘Product’ y luego ‘Test. Con esto se lanza un Build de la aplicación y se ejecutarán los pasos grabados.</br>
                &rarr; Screenshots IOS apps con Fastline.</br>
                Fastline nos facilita la obtención las capturas de nuestra Aplicación. los pasos a seguir son los siguientes:</br>
                1. Tener Fastlane instalado:</br>
                - Ejecutar en el terminal el comando $[sudo] gem install fastlane -NV. </br>
                2. Crear un Target con UITest en el proyecto(puede venir por defecto).</br>
                - Nos podemos fijar si contamos con un Target de UITests en el proyecto.</br>
                - Debemos comprobar si se encuentra la carpeta que termina en UITests en el proyecto.</br>
                </br><center> <img class="centrado" src="images/s722.png" ></center></br>
                3. Ejecutar “fastlane snapshot init” en la carpeta del proyecto.</br>
                - Al ejecutar ese comando  en la raíz del proyecto por el terminal se crearán los siguientes archivos.</br>
                </br><center> <img class="centrado" src="images/s723.png" ></center></br>
                4. Agregar el archivo ./SnapshotHelper.swift a el proyecto dento de UITest.</br>
                - En el Target, nos dirigimos a 'UITests' y presionamos botón derecho, luego pinchamos 'add Files'y buscamos el archivo que puede estar en la raíz o en la carpeta fastlane</br>
                </br><center> <img class="centrado" src="images/s724.png" ></center></br>
                5. Crear o configurar el esquema  con la opción Shared activado.</br>
                - En la configuración de los 'schemas, Activar `Shared` para que lo pueda ejecutar Jenkins.
                </br><center> <img class="centrado" src="images/s726.png" ></center></br>
                </br><center> <img class="centrado" src="images/s727.png" ></center></br>
                6. En la clase UITest grabar una prueba de interacción.</br>
                - Al igual que en las pruebas de interacción, presionando el botón 'record'.</br>
                7. Agregar en el código de prueba snapshot("cap"), para indicar cuando debe tomar las capturas.</br>
                </br><center> <img class="centrado" src="images/s728.png" ></center></br>
                8. Agregar  el siguiente código en el Setup del UITest.</br>
                </br><center> <img class="centrado" src="images/s721.png" ></center></br>
                </br><center> <img class="centrado" src="images/s730.png" ></center></br>
                9. Por último editar el archivo Snapfile.
                </br><center> <img class="centrado" src="images/s731.png" ></center></br>
                &rarr; <big>Integración Testing</big></br>
                Las distintas pruebas creadas, se especificaron de tal manera que Jenkins era el encargado de ponerlas en marcha. Las pruebas unitarias desarrolladas para IOs y Android tienen la ventaja que se pueden ejecutar al momento de realizar la compilación del proyecto, gracias a ello Jenkins puede realizar las pruebas dependiendo de la programación que se le asigne.</br>
                Respecto a las pruebas que se aplicaron al Backend, también se contó con la posibilidad de implementarlas en Jenkins, y poder ponerlas en marcha el momento en que se desee.</br>

            </code>
          </p>
        </br>
        <div class="card-action">
          <a target="_blank" href="https://aws.amazon.com/es/devops/continuous-integration/" style="font-size: 15px; color:#0d47a1;" ><u>Automatización de pruebas sobre una API: Postman y Jenkins</u></a>
          <a target="_blank" href="http://www.codingpedia.org/ama/how-to-test-a-rest-api-from-command-line-with-curl/"style="font-size: 15px; color:#0d47a1;"><u>Todo sobre Curl</u></a>
        </div>
        <div class="card-action">
          <a target="_blank" href="http://blog.hunabsys.com/pruebas-automaticas-de-ui-en-xcode-7/" style="font-size: 15px; color:#0d47a1;" ><u>Pruebas unitarias de UI Xcode</u></a>
          <a target="_blank" href="https://www.raywenderlich.com/150073/ios-unit-testing-and-ui-testing-tutorial"style="font-size: 15px; color:#0d47a1;"><u>Testing unitario sobre IOs</u></a>
        </div>
      </div>
    </div>
<!-- *************************************************************************************************+***************-->
    <br>  <!--semana 8-->
<!-- *************************************************************************************************+***************-->
<div class="card ">
  <div class="card-content teal darken-1" > <!--COLOR DEL FONDO DE LAS CARD -->
    <span style = "color:white; font-size: 50px;" class="card-title"><b><TT><u>FINALIZACIÓN</u></tt><b></span></br>
      <p>
        <CODE style="font-size: 18px; color:#fafafa;">
              &rarr; <big>Despliegue continuo de las aplicaciones a las Stores.</big></br>
              Una de las etapas del desarrollo que no fue concretada, corresponde al deployment continuó con las tiendas de aplicaciones de de Android y IOs, los procesos tiene limitantes como la de pago de suscripciones a las tiendas, llenar una serie de formularios y adjuntar pantallazos  de las vistas de la aplicaciones.  Por recomendación y de forma de poder optimizar estos procesos  sugerimos hacer uso de la herramienta Fastlane , que específicamente nos ayuda a automatizar las capturas de pantallas, hacer deployment de las versiones alfas y betas, hacer el deployment de producción a la store.</br>
              </br><center> <img class="centrado" src="images/s81.png" ></center></br>
              &rarr; <big>Despliegue de aplicaciones Android</big></br>
              Como no fue posible subir nuestras aplicaciones a las tiendas. Se configuró Jenkins para que este entregue al archivo ‘.apk’, que permite instalar las aplicaciones en los dispositivos con el sistema operativo Android.</br>
              Para ello es necesario ir a las configuraciones de la tarea, pinchar la opción ‘añadir una acción’ y seleccionar ‘Guardar los archivos generados’.</br>
              </br><center> <img class="centrado" src="images/s82.png" ></center></br>
              </br><center> <img class="centrado" src="images/s83.png" ></center></br>
        </code>
      </p>
    </br>
    <div class="card-action">
      <a target="_blank" href="https://fastlane.tools/" style="font-size: 15px; color:#0d47a1;" ><u>Fastlane</u></a>
      <a target="_blank" href="http://donmik.com/subir-app-a-la-app-store-sin-morir/" style="font-size: 15px; color:#0d47a1;" ><u>Subir aplicación a la App Store </u></a>
      <a target="_blank" href="https://elandroidelibre.elespanol.com/2014/07/como-publicar-una-app-en-google-play-al-detalle.html" style="font-size: 15px; color:#0d47a1;" ><u>Publicar aplicación en Google Play</u></a>
    </div>
  </div>
</div>
<!-- *************************************************************************************************+***************-->

<footer class="page-footer teal">
  <div class="container">
    <div class="row">
      <div class="col l6 s12">
        <h5 class="white-text">Equipo de trabajo</h5>
        <p class="grey-text text-lighten-4">   &#9679; Felipe Oyarzun // foyarzun@optimisa.cl</br>
          &#9679; Ignacio Huichal // ihuichal@optimisa.cl </br>
          &#9679; Oscar Schnake // oschnake@optimisa.cl </p>
        </div>
        <div class="col l3 s12">
          <h5 class="white-text">Práctica profesional</h5>
        </div>
        <div class="col l3 s12">
          <h5 class="white-text">2018</h5>
        </div>
      </div>
    </div>
    <div class="footer-copyright">
      <div class="container">
        Made by <a class="brown-text text-lighten-3" href="http://www.optimisa.cl/">Optimisa</a>
      </div>
    </div>
  </footer>

  <!--  Scripts-->
  <script src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
  <script src="js/materialize.js"></script>
  <script src="js/init.js"></script>

</body>
</html>
