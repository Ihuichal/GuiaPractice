<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Práctica Profesional</title>
  <style>
  body {
    background-color:#26a69a;
  }
  </style>

  <!-- CSS  -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link href="css/materialize.css" type="text/css" rel="stylesheet" media="screen,projection"/>
  <link href="css/style.css" type="text/css" rel="stylesheet" media="screen,projection"/>
</head>

<body >

      <div id="index-banner" class="parallax-container">
        <div class="section no-pad-bot">
          <div class="container">
            <br><br>
            <h1 class="header center teal-text text-lighten-2">DOCUMENTACIÓN</h1>
            <div class="row center">
                <div><img src="images/optilogo.png"></div>
            </div>
            <br><br>
          </div>
        </div>
        <div class="parallax"><img src="images/imadoc.jpg" alt="Unsplashed image img 1"></div>
      </div>

<!-- *************************************************************************************************+***************-->
<div id="index-banner" class="documentation">
  <!-- *************************************************************************************************+***************-->
  <div class="card ">
    <div class="card-content teal darken-1" > <!--COLOR DEL FONDO DE LAS CARD -->
      <span style = "color:white; font-size: 50px;" class="card-title"><b><TT><u>Semana 1</u></tt><b></span></br>
        <p style="font-size: 18px;"> <CODE style="color:#fafafa;">
          Ante la propuesta de trabajo, la cual consiste en desarrollar aplicaciones móviles nativas,
          que son las que se desarrollan específicamente para cada sistema operativo, lenguaje Swift
          para iOS, Java para Android. Con el foco principal apuntando a la integración continua,
          lo que se traduce en compilar y ejecutar pruebas en todo el código que se va generando.</br>
          La primera actividad consiste en estudiar y posteriormente seleccionar las herramientas
          para trabajar. En este contexto, iniciamos con las instalación de los entornos de
          desarrollo Android Studio y Xcode, se crearon cuentas en GitHub y Jira Atlassian, así ya contabamos con herramientas
          de almacenaje y gestión del proyecto.</br>
          A pesar de que existen más oferta con respecto a herramientas de repositorio y gestión
          de proyectos, se decidió trabajar con GitHub por la razón de que se tenía una
          idea formada de cómo se utiliza apropiadamente, por otro lado Jira Atlassian
          fue escogido por ser desconocido y ademas por que la empresa en sí, quería
          familiarizarse con esta herramienta.</br>
          Una vez instaladas las herramientas, se inició con la ejecución de una serie
          de tutoriales para desarrollar aplicaciones móviles y a la vez hacer uso de los
          repositorios y el instrumento de gestión.</br>
          Para la realización de los tutoriales se utilizó la documentación existente en
          las paginas de Android y Apple respectivamente, con ello se nos permitió hacer
          distintos tipos de pruebas las cuales van desde hacer un “Hello World”, hasta hacer
          una conexión “http” o “https”.</br>
          Luego, se eligió una herramienta de integración continua para estudiarla y ponerla en
          marcha con una de las aplicaciones creadas como prueba. Jenkins fue el instrumento escogido,
          se logro instalarlo en un servidor local, enlazarlo con un proyecto alojado en GitHub,
          de modo que cada cierto tiempo realizaba una compilación del código y en caso de encontrar
          algún error, este quedaria registrado, para poder arreglarlo. </br>
          Para integrar Jenkins, es necesario instalar una serie de plugins como soporte dependiendo
          del tipo de aplicación que se esté desarrollando, ya que existen plugins diferentes para
          aplicaciones Android y IOs. Esto permitirá que reconozca el lenguaje y efectué la compilación
          correctamente.</br>
        </code>
      </p>
    </br>
    <div class="card-action">
      <a target="_blank" href="https://aws.amazon.com/es/devops/continuous-integration/" style="font-size: 15px; color:#0d47a1;" ><u>Integración continua</u></a>
      <a target="_blank" href="http://qode.pro/blog/que-es-una-app-nativa/"style="font-size: 15px; color:#0d47a1;"><u>Aplicaciones móviles nativas</u></a>
    </div>
    <div class="card-action">
      <a target="_blank" href="https://developer.android.com/studio/index.html?hl=es-419" style="font-size: 15px; color:#0d47a1;"><u>Android Studio</u></a>
      <a target="_blank" href="https://developer.apple.com/xcode/" style="font-size: 15px; color:#0d47a1;"><u>Xcode</u></a>
      <a target="_blank" href="https://github.com/" style="font-size: 15px; color:#0d47a1;"><u>GitHub</u></a>
      <a target="_blank" href="https://es.atlassian.com/software/jira" style="font-size: 15px; color:#0d47a1;"><u>Jira Atlassian</u></a>
      <a target="_blank" href="https://jenkins.io/" style="font-size: 15px; color:#0d47a1;"><u>Jenkins</u></a>
    </div>
    <div class="card-action">
      <a target="_blank" href="https://developer.android.com/develop/index.html" style="font-size: 15px; color:#0d47a1;"><u>Documentación Android</u></a>
      <a target="_blank" href="https://developer.apple.com/documentation/" style="font-size: 15px; color:#0d47a1;"><u>Documentación Apple</u></a>
    </div>
  </div>
</div>
<!-- *************************************************************************************************+***************-->
</br>   <!--Semana 2-->

<div class="card ">
<div class="card-content teal darken-1" > <!--COLOR DEL FONDO DE LAS CARD -->
  <span style = "color:white; font-size: 50px;" class="card-title"><b><TT><u>Semana 2</u></tt><b></span></br>
    <p style="color:#fafafa; font-size: 18px;">
      <CODE>
        En este periodo ya había una idea más clara sobre que se tenía que desarrollar,
        pero se decidió por seguir haciendo distintas pruebas de modo de lograr integrar
        Jenkins tanto a aplicaciones Android y IOs. </br>
        Se desarrolló una aplicación en Android la cual, al presionar un botón
        se obtiene la dirección Mac del dispositivo.</br>
        Las aplicaciones, fueron almacenadas en el repositorio Github y para esto se utilizaron
        una serie de comandos en la terminal para registrar los avances.</br>
        Entre los comandos usados tenemos:</br>
        &#9702; git init : para iniciar repositorio en un directorio.</br>
        &#9702; git add. : para agregar todo el contenido modificado o nuevo.</br>
        &#9702; git commit -m “mensaje” : se utiliza para consignar un conjunto de cambios.</br>
        &#9702; git push : usado para subir los archivos.</br>
        &#9702; git branch : se utilizó para crear funcionalidades sin dañar la rama principal.</br>
        &#9702; git checkout : se usa para moverse entre ramas o commits.</br>
        &#9702; git merge : utilizado para fusionar las nuevas funcionalidades creadas
        en las ramas con la rama master.</br>
        Lo presentado hasta en su mayoría está dentro de la capa de presentación (Front end),
        esto dado que es más simple trabajar. </br></br>
        Se empezó a trabajar la parte referente a la capa de acceso a datos (Back end),
        para ello se decidió trabajar con Node.js y MongoDB el cual es una base de datos NoSQL.</br>
        Node.js hoy en día juega un papel importante en la pila de tecnologías de muchas empresas
        de alto perfil, es por ello que se decidió contar con esta herramienta. Respecto a MongoDB
        esta es considera la base de datos NoSQL líder y debido a que existe mucha documentación
        sobre su uso, se decidio por optar por ella.</br>
        Para poner en marcha esta parte, se partió estudiando como definir una API,
        como configurar mongo para tener una base de datos local y como hace conexión del
        dispositivo móvil con un servidor, utilizando el protocolo Http.</br>
      </code>
    </p>

    <div class="card-action">
      <a target="_blank" href="https://nodejs.org/es/" style="font-size: 15px; color:#0d47a1;" ><u>Node.js</u></a>
      <a target="_blank" href="https://www.mongodb.com/es" style="font-size: 15px; color:#0d47a1;" ><u>MongoDB</u></a>
      <a target="_blank" href="http://rogerdudler.github.io/git-guide/index.es.html" style="font-size: 15px; color:#0d47a1;" ><u>Guía GitHub</u></a>
    </div>
  </div>
</div>
<!-- *************************************************************************************************+***************-->
</br>  <!--Semana 3-->

<div class="card ">
<div class="card-content teal darken-1" > <!--COLOR DEL FONDO DE LAS CARD -->
  <span style = "color:white; font-size: 50px;" class="card-title"><b><TT><u>Semana 3</u></tt><b></span></br>
    <p>
      <CODE style="color:#fafafa; font-size: 18px;">
      Se inició el desarrollo de la aplicación móvil para Android,
      haciendo uso de git para desarrollar el proyecto en módulos,
      entre las tareas más destacadas podemos diferenciar las siguientes: </br>
      &#9702; Módulo para obtener la Geoposición.</br>
      &#9702; Método para obtener id “Mac”.</br>
      &#9702; Módulo de comunicación Https.</br>
      &#9702; Vista de la aplicación.</br>
      Estructura de la aplicación: </br>
      El framework de android separa el proyecto en directorios </br>
    </br><center><img class="centrado" src="images/s31.png" ></center></br>
    APP: se separa en tres sub directorios: </br>
    &#9702; Manifests:Contiene el archivo que con los permisos y configuraciones
    iniciales de la Aplicación.</br>
    &#9702; Java:Contiene los archivos con las clases en java donde se programan
    las lógicas de la aplicación.</br>
    &#9702; Res: Contiene los archivos de las vistas, para el diseño de
    vistas de la app, los archivos de aca son de lenguaje de etiquetas xml donde
    se pueden definir  recursos de widget como botones, labels, formularios, etc.</br>

    &#8211; Método para obtener  la posición</br>
    Para este método se usaron las librerías que proporciona android para detectar
    la posición del celular mediante GPS, Location Manager  es una clase que nos permite
    capturar esta información, además de otras clases para almacenar las instancias como
    Location() y location Listener.</br>

    &#8211; Método para obtener la mac del dispositivo :</br>
    MacDevice.java es una clase que se ejecuta en el dispositivo y
    retorna un string con la mac. </br>

    &#8211; Comunicación HTTPS</br>

    Para ejecutar peticiones HTTPS tuvimos que crear clases que
    extienden de la Clase AsincronycTasck(), para mantener la comunicación
    en otro hilo de ejecución, además de importar la librería HttpsUrlConnection()
    que sostiene los métodos para formar las peticiones Response y brinda de un mecanismo
    para tratar los Response.</br>

    &#8211; Cambio de repositorio </br>

    Para seguir con el  alineamiento estratégico de la empresa
    decidimos cambiar de servidor de repositorio  de GitHub a Bitbucket
    puesto que este último es una Herramienta de Atlassians y pensamos que nos
    podría dar sinergia con Jira.</br>

    &#8211; Vista de la aplicación </br>

    En el directorio res  se encuentran los Layouts que describen
    tanto en forma gráfica como lenguaje xml los componentes de las vistas </br>

  </br><center> <img class="centrado" src="images/s32.png"></center></br>
  &#8211; Servidor local </br>

  Para hacer pruebas de comunicación  levantamos un servicio de
  Api local con Node Js utilizando el Framework de Express conectado
  con una base de datos mongodb.  </br> </code>
</p></br>
<div class="card-action">
  <a target="_blank" href="https://aws.amazon.com/es/training/?nc2=h_l2_tr" style="font-size: 15px; color:#0d47a1;" ><u>Capacitación</u></a>
  <a target="_blank" href="https://docs.aws.amazon.com/es_es/apigateway/latest/developerguide/welcome.html" style="font-size: 15px; color:#0d47a1;" ><u>API Gateway</u></a>
</div>
</div>
</div>

<!-- *************************************************************************************************+***************-->
</br>  <!--Semana 4-->

<div class="card ">
<div class="card-content teal darken-1" > <!--COLOR DEL FONDO DE LAS CARD -->
  <span style = "color:white; font-size: 50px;" class="card-title"><b><TT><u>Semana 4</u></tt><b></span></br>
    <p>
      <CODE style="color:#fafafa; font-size: 18px;">
      Amazon nos proporciona una gran cantidad de servicios, los que utilizamos
      para efectos del primer sprint de desarrollo son solo 2, (Lambda, y Api GateWay) y
      se propone agregar el uso de DynamoDB para los próximos Sprint. </br>
      Funciones en Lambda: </br>
      Una función es un código con entradas que será ejecutado por Amazon y que pueden efectuar
      una acción que puede interactuar con otros recursos de amazon, estas funciones pueden ser escritas
      en varios lenguajes por ejemplo Java, C, Python, NodeJs, nosotros elegimos usar NodeJs para
      conservar el modelo que teníamos como backend que teniamos en Express js. </br>
      Ejemplo de función con Lambda: </br>
      Para crear una función de Lambda, se hace de la siguiente forma:</br>
      Dentro de AWS selecciona el servicio de Lambda, y selecciona
      la opción de crear una nueva función. </br>

  </br><center> <img class="centrado" src="images/s41.png" ></center></br>


    Ahora hay que completar los siguientes campos nombre de la funcion,
    descripcion, runtime y role. </br>


</br><center> <img class="centrado" src="images/s42.png" ></center></br>


  Nombre: Debes poner un nombre para identificar tu función. </br>
  Descripción: Permite poner una descripción de la función. </br>
  Runtime: Corresponde al intérprete en el cual  correrá el código, puede ser Java,
  Python, Script. </br>
  Role: Los roles en amazon definen los permisos que nuestra funcion tendra con
  otros recursos y servicios de Amazon. ver IAM de amazon para gestionar roles.</br></br>

  Completado los recursos ahora ya tienes una funcion hecha en Lambda, nosotros escogimos
  usar NodeJs para codificar nuestras funciones, Los recursos a los cuales nuestras
  funciones podrán acceder las dará el role que se le asigne a la función. mientras que
  los triggers se pueden configurar desde la función. para efectos de nuestro primer sprint,
  hicimos una función que retorna  un atributo de la llegada.</br>


</br> <center><img class="centrado" src="images/s43.png" ></center></br>

Las entradas de una función de Lambda son estructuras del tipo Json por como el siguiente:</br>
</br> <center><img class="centrado" src="images/s44.png" ></center></br>

Estas  pueden provenir del API Gateway si lo configuras como Trigger
de lanzamiento para la función, aunque igual puede ser ejecutado por
varios otros servicios de amazon.</br>
En nuestro caso lo configuramos pensando en recibir una
llamada proveniente de API Gateway. </br>
</br> <center><img class="centrado" src="images/s45.png" ></center></br>

API Gateway es un servicio que facilita la comunicación de los demás servicios
de amazon proporciona sistemas de Rooteos y sistemas de autentificación que le
pondremos el foco en la siguiente sprint. pero lo dejamos configurado para que
reciba las peticiones HTTPs  provenientes de nuestra aplicacion y las comunique con
el microservicios de lamda.</br>
</br> <center><img class="centrado" src="images/s46.png" ></center></br>

</p>

</code>
</br>
<div class="card-action">
<a target="_blank"  href="https://aws.amazon.com/es/free/?sc_channel=PS&sc_campaign=acquisition_CL&sc_publisher=google&sc_medium=english_cloud_computing_hv_b&sc_content=aws_core_e&sc_detail=aws&sc_category=cloud_computing&sc_segment=188900648287&sc_matchtype=e&sc_country=CL&s_kwcid=AL!4422!3!188900648287!e!!g!!aws&ef_id=WldLDQAAADmz96cK:20180202155127:s" style="font-size: 15px; color:#0d47a1;" ><u>Amazon Web Services</u></a>
</div>
</div>
</div>
<!-- *************************************************************************************************+***************-->
<br>  <!--semana 5-->
<div class="card ">
<div class="card-content teal darken-1" > <!--COLOR DEL FONDO DE LAS CARD -->
  <span style = "color:white; font-size: 50px;" class="card-title"><b><TT><u>Semana 5</u></tt><b></span></br>
    <p>
       <CODE style="color:#fafafa; font-size: 18px;">
         Luego de desarrollar la aplicación móvil para dispositivos Android, no en su totalidad.
         se comenzó el desarrollo de la aplicación para dispositivos IOs, para esto se ocupo el lenguaje de
         programación Swift y Xcode como entorno de desarrollo. Se utilizó la documentación oficial y una serie
         de tutoriales para construir la aplicación.</br>
         La aplicación construida consiste únicamente en enviar datos a una base de datos NOSQL,
         esto al momento de presionar un botón, y una serie de validaciones para ello.</br>
       </br> <center><img class="centrado" src="images/s51.png" ></center></br>
        Al presionar el botón “REGISTRAR AHORA”, se envia una dirección del dispositivo
        como identificador, y los datos de la ubicación, esto es coordenadas latitud y longitud.
        Al legar al servidor, primero comprueba si la dirección del dispositivo corresponde a
        un usuario registrado, en caso contrario devuelve error como respuesta. Luego con los valores latitud
        y longitud utilizando la API de google, determina la dirección desde la cual se envían los datos.
        Finalmente los datos se registran en la base de datos, adjuntando el nombre asociado al dispositivo,
        dirección, hora actual, id del dispositivo, latitud y longitud.</br>
        Una vez que la aplicación ya realizaba las funciones descritas, se puso en marcha
        la adaptación de Jenkins para las aplicaciones desarrolladas para Android y IOs.</br>
        El objetivo de esto era establecer una herramienta que estuviera atenta  al sistema de control
        de versiones (Bitbucket) para revisar los cambios. Cada vez que detectara un cambio,
        la herramienta de manera automática compilara, con la idea de detecta si algo va mal,
        para notificar o simplemente evidenciar que todo sigue funcionando correctamente.</br> Con
        esto se estaría empleando integración continua de una forma sencilla.</br>
        La instalación de Jenkins se realizó en un computador de los miembros del equipo,
        de modo que se utilizo un servidor local para tener andando el software. Los pasos para la
        instalación de Jenkins, se pueden obtener directamente de la pagina oficial.</br>
        Para emplear el uso de Jenkins, lo primero es instalar el plugin “Bitbucket Plugin”,
        después se debe proporcionar el acceso a los repositorios Bitbucket. Como se definieron como privados,
        los pasos para tener acceso a ellos es el siguiente:</br>
         &#9702; Abrir una terminal.</br>
         &#9702; Ejecutar $sudo su jenkins.</br>
         &#9702; Ejecutar $shh-keygen.</br>
         &#8211; Presionar “enter" tres veces.</br>
        Con estos pasos ya se puede obtener una ssh-keygen. El paso siguiente es agregar
        esta llave a bitbucket y asignarle un nombre.</br>
        </br><center> <img class="centrado" src="images/s52.png" ></center></br>
        </br><center> <img class="centrado" src="images/s53.png" ></center></br>
        El paso siguiente, es ir a Jenkins y agregar una credencial asociada a la SSH key.</br>
        </br><center> <img class="centrado" src="images/s54.png" ></center></br>
        </br><center> <img class="centrado" src="images/s55.png" ></center></br>
        </br><center> <img class="centrado" src="images/s56.png" ></center></br>
        Finalmente, para asociar un repositorio a una tarea creada en Jenkins, hay que
        dirigirse a configuración de la tarea y hacer lo siguiente:</br>
        </br><center> <img class="centrado" src="images/s57.png" ></center></br>
        Se pega en enlace SSH que proporciona Bitbucket, y se asocia a la credencial creada.</br></br>
        Realizar configuración de Jenkins, para ejecutar pruebas en el código fuente,
        no es algo trivial, de hecho para cada tipo de desarrollo existen características diferentes.</br>
        Para adaptarlo al proyecto IOs, se encuentra el plugin “Xcode Integration”, el cual permite compilar
        el código fuente.</br>
        A continuación se muestra la adecuación de realizada en el software:</br>
        </br><center> <img class="centrado" src="images/s58.png" ></center></br>
        </br><center> <img class="centrado" src="images/s59.png" ></center></br>
        </br><center> <img class="centrado" src="images/s510.png" ></center></br>
        Para adaptarlo a proyectos Android, se debe instalar el plugin “Gradle Plugin”.
        Además se deben configurar una serie de variables de entorno.</br>
        A continuación se muestra la adecuación de realizada en el software:</br>
        </br><center> <img class="centrado" src="images/s511.png" ></center></br>
        </br><center> <img class="centrado" src="images/s512.png" ></center></br>
        </br><center> <img class="centrado" src="images/s513.png" ></center></br>
        Luego de configurar, la manera de iniciar una prueba es precionar la opción "Construir ahora".
        La manera que tiene Jenkins de evidenciar el estado actual de un proyecto,
        es por medio de simbolo de colores. El azul significa que todo va bien y rojo que
        se produjo algún error, además la herramientas proporciona un historia de los resultados obtenidos</br>
        </br><center> <img class="centrado" src="images/s514.png" ></center></br>
        </br><center> <img class="centrado" src="images/s515.png" ></center></br>
      </code>
     </p>

</br>
<div class="card-action">
  <a target="_blank"  href="http://mmorejon.github.io/blog/integracion-continua-jenkins-ios9-xcode/" style="font-size: 15px; color:#0d47a1;"><u>Tutorial configuración Jenkins para IOs</u></a>
  <a target="_blank"  href="https://www.cloudbees.com/blog/building-android-gradle-apps-jenkins" style="font-size: 15px; color:#0d47a1;"><u>Tutorial configuración Jenkins para Android</u></a>
</div>
</div>
</div>
<!-- *************************************************************************************************+***************-->
<br>  <!--semana 6-->
<div class="card ">
<div class="card-content teal darken-1" > <!--COLOR DEL FONDO DE LAS CARD -->
  <span style = "color:white; font-size: 50px;" class="card-title"><b><TT><u>Semana 6</u></tt><b></span></br>
    <p>
       <CODE style="color:#fafafa; font-size: 18px;">
         &#8211; Lambda AWS localmente.</br>
         Trabajar Localmente con las funciones de lambda, equivale a una ventaja para avanzar colaborativamente.</br>
         Esto se logró, primero creando una carpeta con la estructura apropiada al Back-End.
         Luego se utilizó el gestor de paquetes "npm", y se instalaron los siguientes paquetes,
         uno para tener los accesos a los servicios de Amazon y otro para utilizar Lambda de forma local:</br>
         &#9702; npm install aws-sdk
         &#9702; npm install -g lambda-local
         luego de esto, en el código se deben agregar las Key de acceso de usuario a los servicios AWS.
         Una vez realizado los pasos mencionados, basta con ejecutar en terminal una instrucción de prueba:
         &#9702;lambda-local -l server.js -e event.js
         Donde event.js es un elemento para hacer un test, tiene la estructura siguiente:</br>
         module.exports =</br>
         {</br>
         "IdDevice":"0-a-f5-4f-90-74",</br>
         "latitud":"-33.417641",</br>
         "longitud":"-70.610304"</br>
         };</br>
         Esto simula el botón test que proporciona AWS</br>
         </br><center> <img class="centrado" src="images/s61.png" ></center></br>
         </br><center> <img class="centrado" src="images/s62.png" ></center></br>
         </br><center> <img class="centrado" src="images/s63.png" ></center></br>
         &#8211; Deployment Funciones en lambda.</br>
         Para automatizar el deployment de las funciones de lambda en la nube desde el
         repositorio usamos 2 alternativas, plugins AWS-lambda  y  pipeline de bitbucket.</br></br>
         &#9702; Plugin AWS-lambda para jenkins.</br>
         Jenkins es nuestro servidor de integración y despliegue continua por defecto.
         cuenta con varios plugins que nos ayuda a automatizar varios procesos de  desarrollo
         como el de las pruebas automatizadas, para el caso de Lambda utilizamos un plugins
         “AWS Lambda Plugin”, que nos ayuda a automatizar el Despliegue de la aplicación.</br>
         Para utilizar este plugins la mecánica es crear una “tarea”, configurarla para bajar
         temporalmente la función desde nuestro repositorio de Bitbucket, Darle las credenciales de
         nuestra cuenta de amazon al servidor Jenkins mediante el plugins, y llenar las configuraciones
         de nuestra función de lambda. </br>
         </br><center> <img class="centrado" src="images/s64.png" ></center></br>
         los campos requeridos para el Deployment </br>
        &#8226; AWS ACCESS KEY ID : ID que proporciona AWS por medio de las cuentas de usuario.</br>
        &#8226; AWS Secret Key : Clave secreta del Id Access AWS.</br>
        &#8226; AWS Region : Region del servidor Aws donde se encuentra función de lambda.</br>
        &#8226; Funtion name : Nombre de la función a actualizar, si no existe se creará otra con ese nombre. </br>
        &#8226; Role : a cada función se le asigna un role que cuenta con los permisos para interactuar con los servicios
        de amazon inclusive los permisos para editar la app </br>
        &#8226; Artifactact Location : Refiere a la locación donde se encuentra
        ubicado el proyecto que se quiere subir a producción. hay varias opciones.
        (enviar un directorio, un zip, o  extraerla de s3 AWS(servicio de almacenamiento de Amazon)
        en nuestro caso  le dimos la ruta “/Users/Shared/Jenkins/Home/workspace/lambda” que alude a
        la carpeta donde se baja temporalmente  nuestro repositorio  en cada tarea.</br>
        &#8226; Handler name : Nombre del controlador de la función en lambda por defecto es Index.handler,
        depende del nombre del archivo principal que contiene la el método handler  de la función,
        en nuestro caso es Index.handler porque el archivo principal de llama server.js</br>
        &#8226; Memory Size:  Se le indica la cantidad de memoria que vamos a requerir para
        ejecutar este microservicio por defecto son 128 MB. </br>
        &#8226; Time out: Tiempo de corte para la  ejecución del microservicio.</br>
        &#8226; Runtime : lenguaje o compilador que ejecutará la función </br>
        &#8226; Update mode : Se llena con “full por defecto”</br></br>
        &#9702; PipeLine de Bitbucket </br>
        El servidor de repositorio Bitbucket  nos proporciona de un servicio
        de ejecución para nuestros códigos en la nube. este se puede aprovechar
        para hacer pruebas de integración y además para ejecutar script que nos permitan
        realizar Deployment continuo.</br>
        Para nuestro proyecto de microservicios en Lambda AWS utilizamos un
        script que automatiza el despliegue de las funciones desde el repositorio.</br>
        Los pipeline corren Script del tipo yml, incluimos en la raiz del proyecto
        el archivo bitbucket-pipelines.yml  con las instrucciones para hacer  en cada ejecución.</br>
       </br><center> <img class="centrado" src="images/s65.png" ></center></br>
       Este script requiere en cada instancia instalar zip para comprimir el repositorio.
       Instalar “boto3”, que es una librería requerida para comunicarse con amazon, y ejecuta
       un programa escrito en python llamado lambda_deploy.py que contiene la logica para enviar
       el zip a Amazon Lambda. </br>
       Las credenciales de Amazon para la enviar y editar las funciones de lambda en la
       nube se deben guardar en las variables de entorno de PipeLine de Bitbucket</br>
       </br><center> <img class="centrado" src="images/s66.png" ></center></br>
       Este método de Deployment es bastante cómodo porque es automatizado,
       con la actualización del repositorio de producción. cada ejecución se
       demora cerca de 40 segundos, tiempo que hay que considerar dado que pipeline
       de bitbucket tiene una capa gratuita de 50 minutos mensuales ampliables. Lo que
       podría ser suficiente para subir 80 versiones al mes. </br></br>
      &#8211; DIAGRAMA DE ARQUITECTURA DE DEPLOYMENT CONTINUO PARA FUNCIONES DE LAMBDA USANDO JENKINS </br>
      </br><center> <img class="centrado" src="images/s67.png" ></center></br>
      </code>
     </p>

</br>
<div class="card-action">
  <a  target="_blank" href="https://www.npmjs.com/package/lambda-local" style="font-size: 15px; color:#0d47a1;"><u>Lambda local</u></a>
  <a target="_blank" href="https://plugins.jenkins.io/aws-lambda" style="font-size: 15px; color:#0d47a1;"><u>Plugin Lambda AWS para Jenkins</u></a>
  <a target="_blank" href="https://bitbucket.org/awslabs/aws-lambda-bitbucket-pipelines-python" style="font-size: 15px; color:#0d47a1;"><u>Despliegue con Bitbucket</u></a>
  <a target="_blank" href="https://confluence.atlassian.com/bitbucket/limitations-of-bitbucket-pipelines-827106051.html" style="font-size: 15px; color:#0d47a1;"><u>Restricciones del despliegue con Bitbucket</u></a>
</div>
</div>
</div>


<!-- *************************************************************************************************+***************-->
<!-- *************************************************************************************************+***************-->
<!-- *************************************************************************************************+***************-->
<!-- *************************************************************************************************+***************-->

<!-- *************************************************************************************************+***************-->



    <footer class="page-footer teal">
            <div class="container">
              <div class="row">
                <div class="col l6 s12">
                  <h5 class="white-text">Equipo de trabajo</h5>
                  <p class="grey-text text-lighten-4">   &#9679; Felipe Oyarzun // foyarzun@optimisa.cl</br>
                    &#9679; Ignacio Huichal // ihuichal@optimisa.cl </br>
                    &#9679; Oscar Schnake // oschnake@optimisa.cl </p>


                  </div>
                  <div class="col l3 s12">
                    <h5 class="white-text">Práctica profesional</h5>

                  </div>
                  <div class="col l3 s12">
                    <h5 class="white-text">2018</h5>

                  </div>
                </div>
              </div>
              <div class="footer-copyright">
                <div class="container">
                  Made by <a class="brown-text text-lighten-3" href="http://www.optimisa.cl/">Optimisa</a>
                </div>
              </div>
            </footer>


            <!--  Scripts-->
            <script src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
            <script src="js/materialize.js"></script>
            <script src="js/init.js"></script>

    </body>
</html>
